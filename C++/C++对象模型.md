# C++对象模型笔记2.0

## 目录
- 基础概念
- C与C++
- C++

## 基础概念
|概念|意义|
|-----|-----|
|声明|是指标识符|
|定义|是指占用内存的行为|


## C与C++
- 从C struct上派生C++的部分
    ```
    strtuct C_point {  ... }
    class Point  : public C_point { ... }
    ```
## C++
  - **构造函数**
    - 默认inline，如果函数太复杂，则会被声明为explicit non-inline static函数
    - 无构造函数时，编译器需要时，会生成一个默认构造函数。class 的成员变量不会被初始化
    - 有构造函数时候，编译器会扩充现有的构造函数，而不是生成一个。扩充的内容：在调用构造函数的user代码之前，加上成员变量的默认构造函数
    - 在未写构造函数时，不是所有时候编译器都会生成一个构造函数。只有以下四种条件时候，才会生成
      - class的成员变量中，有默认构造函数
      - class的基类有默认构造函数
      - class有虚函数
      - class有虚基类
    - 对象初始化列表
      - 初始化列表以成员变量在头文件中的声明顺序来初始化
      - 成员变量的初始化，写在初始化列表比写在构造函数中效率更高。
        - 因为，构造函数中会生成一个临时变量，然后调用拷贝构造函数来给成员函数赋值。写在初始化列表中，会在构造函数的user code之前，插入成员变量的直接初始化（在成员变量的内存地址上初始化）的代码，效率更高。
      - 明确的初始化列表
          - 收益：能带来效率上的提升，但不能补偿工程上的缺陷
          - 限制：
            - 只有成员变量都是public才行
            - 只能指定常量，编译器在编译期间才能评估优化
            - 编译器未自动执行，其失败可能性会增高
    - 子类的构造函数，会被编译器加以扩张。以静态调用的方式，调用每一层基类的构造函数。如果父类的构造函数没有声明，则会链接失败
    - 编译器扩充构造函数操作
      - 将初始化列表中的成员变量初始化，放到构造函数中。并以成员变量的声明顺序初始化。
      - 若某成员变量不在列表中，且其有构造函数。则其必须被调用
      - 如果有虚函数指针，则必须初始化，指向只当的虚表
      - 所有的基类构造函数必须被调用，以继承的顺序调用
      - 如果是多重继承的第二个或后边的，this指针需要调整
      - 所有虚基类的构造函数必须被调用，从最深到最浅
    - 构造函数中要显示调用自己类的函数，包括虚函数。此处不要使用虚拟机制
  - **析构函数**
    - 虽然析构函数是虚的，但在其调用位置会被静态决议出来
    - 只有在其成员或者基类中包含析构函数，此类的析构函数才会被编译器自己构造出来。
    - 需要虚构函数的时候才自己提供，不然提供的虚构函数也是低效的。
    - 应该拒绝那种对称策略（有构造函数，则必须有析构函数）的奇怪想法
  - **拷贝函数**
    - 默认inline，如果函数太复杂，则会被声明为explicit non-inline static函数
    - 如果类的函数或者常规函数，包含return class val的形式，提供一个拷贝构造函数比较合理
    - 要做拷贝的自我检查
  - **赋值函数，赋值运算符**
    - 默认inline，如果函数太复杂，则会被声明为explicit non-inline static函数
    - 只有在默认行为不正确或不安全时，才选择提供一个拷贝赋值运算符
    - 由于class有按位复制语义，所以拷贝赋值运算符不会被构造出来
    - 以下情况需要自己写拷贝赋值运算符：
        - class包含一个有拷贝赋值的运算符的成员变量时
        - class的基类有拷贝赋值的运算符时
        - class有虚函数时
        - class继承自有虚函数的类时
    - 如果要拒接一个类obj拷贝复制给另一个obj，则将拷贝赋值运算符声明未私有的，并不提供实现（在链接时会失败）即可
    - 多继承下的拷贝赋值运算符
        - 子类如何抑制基类中父类的拷贝赋值运算符被重复调用？
            - 在子类的拷贝赋值运算符中显示调用基类的拷贝赋值运算符
        - 建议：**不要在虚基类中声明数据**
  - **成员变量**
    - c++标准只要求class的成员变量较晚出现，有较高的地址。并无其它要求.其可以是非连续的
        - 可能因为对齐问题，而导致有字节填充
        - 也有可能填充一些c++需要的隐藏成员变量。如虚函数表的指针
    - 对于public，private，protected声明的不同访问权限的成员变量的排列顺序并无要求
    - 存取形式
      - 显式存取
        - 对成员的存取，可表示为如下代码 : c++对象模型P98页
        ```
        &obj+ ( offset - 1) 
        or
        obj.member
        or
        pointer->member
        ```
        注：通过指针存取member时，无法判断pointer是父类指针还是子类指针，无法判断member是属于父类还是子类，则必须推迟到执行期判断
      - 隐式存取
    - 静态成员变量
         - class的静态成员变量，只有一个实例，存放在程序的数据段。每一次程序对其    取值时，它就会内部转化为对该唯一extern实例的直接参考操作。
         - 静态成员的存取，不会随着继承结构的变化而变化，无论何种形式，都是直接存取。因为其位置是固定的。若取一个静态成员变量的地址，会得到一个其数据类型的指针，因为其不在任何对象中
        - 两个不同的类，生命周期的相同的静态成员变量，会名称冲突。但编译器可能会优化这两个静态成员变量为不同的名字
  - **成员函数**
    - 函数传参
      - 一种方法是生成一个临时calss，送进去
      - 另一种方法是在堆栈上（实际参数应该存在的位置上）拷贝构造一个，然后局部变量会随着堆栈析构掉
    - 函数返回值
      - 会为函数增加一个返回值类型的的引用的额外参数，然后将局部变量的参数拷贝构造给额外参数
      - 函数指针指向有return class的函数，其函数指针类型的声明中也要增加一个返回值引用的额外参数
    - 成员函数会被转化为相应的非成员函数。
      - 对比非成员函数，选择成员函数不应该有什么额外的负担。
      - 静态成员函数会转换为一般的函数调用
    - 成员函数会被name mangling 增加外的信息，和原来的名字一起拼成更细致的名字，以确保独一无二
    - extern C会压制name mangling的效果
    - 对静态成员函数取地址，得到的是一个普通的函数指针
    - 指向成员函数的指针是一个结构体，包含index，faddr，delta三个变量
    对calss data member的取地址，得到的是此成员的偏移量offset
      - data member的指针都被额外增加了1，获得其真实地址都需要减1.为了和不指向data member的指针区分
      - 取实例化（或者静态成员变量的）的类的成员变量的地址，会得到成员变量的类型指针
      - 取类生命的成员变量的地址，会得到成员变量类型+类型生命的指针
      - 虚拟继承会引入一次额外的间接引用。额外的间接性会降低“把所有的东西都搬到寄存器中执行”的优化能力
  - **静态成员函数**
  - **虚函数**
    - 对虚函数取地址，得到的是其在虚函数表中的offset
    - 虚基类的虚函数可以通过虚基类被直接调用
    - 能不写纯虚函数就不写纯虚函数，能实现就实现它
    - 将类的所有函数都声明为虚函数，然后靠编译器去优化，并不是很好的设计理念
    - 虚函数中调用虚函数
      - 再此类的构造函数中，被静态决议为此类的函数。
        - 比较根本的方法是，在执行构造函数后，限制一组虚函数的名单，即虚函数表。则虚函数表应该在基类的构造函数之后，但在程序员的代码之前。初始化完虚函数表后，再进行成员变量list的初始化
        - 但此时还有一个问题：各个基类的可能包含成员变量的初始化列表，调用虚函数
        - 在实际中是安全的，因为虚函数表还未构造。但在语义上是不安全的，因为函数本身可能依赖未构造的成员变量的值
  - **基类**
    - 虚基类中不要声明非静态数据成员
  - 继承
    - 单一继承
    - 多重继承
      - 多重继承会有多个虚表，后来因为效率问题，合成一个表
      - 多继承的虚函数要写的尽量小，（平均为八行）。
      - 因为要增加函数跳转。尽量少的代码有助于跳转效率的提升
    - 虚拟继承
      - base class 不管在继承中倍派生了多少次，永远只会有一个实例
      - 从父类继承来的子类，还会有一个指向父类的指针成员
      - 在class的成员函数后边增加一个指针成员，指向虚继承的索引表和此时的的类型，按类型做相关索引
    - 有虚函数的继承
      - 最好提供赋值运算符和拷贝构造运算符，这样效率降低40%-50%。若让编译器自己生成，则相率降低300%。相对于简单的class来说
    - 虚拟继承，多继承
      - 类似于istream那样，calss被分为两部分，一部分不变区域，一部分共享区域。
      - 不变区域
        - 不管后续如何演化，总有固定的offset，可以直接被存取
      - 共享区域
        - 这一部分的数据，其位置回因为每次派生的操作而有变化，只可以被间接存取。
      - 各家编译器实现的差异，主要表现为三种策略：
        - 一般的布局策略
          - 先安排好子类的不变的部分，然后再建立其共享的部分
        - cfront编译器在每个子类（继承的每一层的子类中）中安插一些指针，指向多继承的父类，来存取父类的成员
          - 缺点
            - 每一个对象针对每一个多继承的父类背负一个额外的指针。然而我们希望class obj有固定的负担。不以为其父类的个数而变化
            - 由于虚继承的链条加长，导致存取层次的增加。如果我们有三层虚继承，就需要三次间接存取（经由三个虚基类的指针）。我们希望有固定的存取时间
        - MetaWare和其他编译器
          - 使用一般策略，但拷贝所有的父类指针放到子类中，来解决固定存取时间的问题
        - Microsoft编译器
          - 对与问题a引入了虚基类表，每个class有一个或者几个虚基类表，由编译器安插一个指针，指向虚基类表。
        - sum编译器
          - 虚函数表可经由正值或者负值来索引。正值索引虚函数，负值索引虚基类
        - 作者喜欢的方法
          - 在虚函数表中，放置虚基类的offset ( 而不是地址)
          - 此策略对继承而来的成员存取操作成本比较昂贵，不过此成本已经被分散至对member的使用上，属于局部成本。
- **执行期语义**
  - new和delete
    - 这两个运算符都是以C语言的malloc和free来实现的
    - 并且允许传入构造和析构函数
    - 并且如果new的size为0；size会被置1
    - 如果new class[10]的class有默认构造函数，则vec_new会被调用
    - new class [size] 对应delete [size] 也可以 delete [ ]
    - 没有提供 [ ] 时候，整个buff的内存会被收回，但只有一个obj会被调用析构函数
    - 避免以一个基类指针指向一个子类所组成的数组。这样是错误的，会对每一个元素调用基类的析构函数，并且作用的内存块也是错误的。因为元的的大小不对，导致偏移的不对
  - 临时变量
    - c++标准允许编译器对于临时变量的处理有绝对的自由度
      - 它可以优化也可以不优化，或者优化的方式也不同.但实际上，由于市场的竞争。都不会产生临时对象
    - c++标准，临时对象（包括多个子表达式）在完整表达式尚未被评估完全之前，不得被摧毁
    - 如果临时对象被绑定到引用上，则临时变量将保留。指导此引用析构才会析构
  - placement operater new : 在一块内存上构造class
    - 会被编译器扩展为两步骤
        1. 在此buff上放置obj
        2. 保证obj的构造函数调用
    - 调用此地址指针下的析构函数后，才能对此buff再次调用placement operater new
    - 传入的buff要跟构建的class一样大或者是一个“新鲜的”（新的）的buff。
    - 不支持继承，虚函数等特性
      - 例如：子类与父类一样大小的情况下，在一个buff上构造父类，人后再此buff上调了父类的析构。再在此buff上构造了子类。在调buff->virtual_fun(),此时不确定会调用父类的虚函数还是子类的，标准不支持
  - 对局部静态变量
    - c++标准现在要求，进入静态局部变量存在的函数时才构造。并且以构造的相反顺序析构。则会保持一个执行期静态局部变量的链表来实现
  - class数组
    - 用vec_new来替换相应的new，对每一个class元素进行构造。相对应的还有vec_delete函数.如果前边一部分元素，被赋予了初始值。则不会调用vec_new，其余剩下的会调用vec_new
    - 对于class的数组，经由指针来调用构造函数，总会比class的绑定少点什么。不能被允许存取默认参数值
  - 建议：
    - 将obj尽可能的定义在使用的代码段附近，这么做可以节省非必要的对象产生和销毁操作。不要像C一样，将变量的定义放在函数的起始处
    - 全局变量需要静态初始化，需要显示初始化。
      - 虽然可以对全局变量在编译器赋值为0，但其构造函数是在执行期才会调用。但在此之前需要对全局变量（放置于程序data段）的初始化做评估同时，子类的全局变量的静态初始化也是同理。在编译期间不能确定其成员变量的位置，需要在执行期才能执行。但在编译期间要做评估求值，以确保其在执行期间能够执行
    - 静态区的全局变量的成员函数或调用的方法，不要包含try等异常机制